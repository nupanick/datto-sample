# datto-sample
A sample coding assignment for an interview with Datto (September 2015). This program finds the word in an input file with the highest frequency of any repeated letter.

Usage: 

    python3 main.py <input file>

Here is the original problem statement, followed my my solution notes.

# Problem

In some English words, there is a letter that appears more than once. Search through a sample of text to find the word with a letter that is repeated more times than any other letter is repeated in any other word. When there is a tie between two words, choose the word that appeared first in the sample.

The text sample will contain only alphabetic characters (“a” through “z” and “A” through “Z”), whitespace, and punctuation marks. The words will be separated by whitespace. A letter is considered to be the same letter regardless of whether it appears in uppercase or lowercase. Any punctuation marks should be ignored—so, in particular, contractions, possessives, and hyphenated words count as a single word.

Each sample is stored in a text file: Write a function that accepts a file path as its argument, and returns the chosen word as its output.

# Example:

*Input:* “O Romeo, Romeo, wherefore art thou Romeo?”

*Output:* “wherefore”

Explanation: The letter “e” is repeated three times in the word “wherefore”—and this is more than any other letter is repeated in any other word!

# Example:

*Input:* “Some people feel the rain, while others just get wet.”

*Output:* “people”

Explanation: Both “people” and “feel” have a letter that is repeated twice within the word. 

This is a tie—and the first word wins!

# My Solution:

I took an depth-first approach to this problem, implementing the most basic code first and then working out. First, I noticed that the only thing that matters in each word is its "repeat index", which is how I will refer to the number generated by counting the repetitions of the word's most common letter, so I wrote the repeatIndex() method to just count letter frequency.

Next, I wanted to make sure I parsed each word correctly, ignoring capitalization and punctuation (although it would be humorous to see a word like "y'all'd've" be the top score, with the apostrophe being its "most common letter", this is probably not in the spirit of the assignment). Removing capitals is relatively easy with str.lower(), but getting rid of the punctuation took a little work. Eventually, I decided what I really wanted was a whitelist of just letters. So sanitize() converts a word to lowercase, then sifts out anything that isn't a letter.

At this point I had the sanitize() method to take care of removing unwanted characters and casings, and the repeatIndex() method to do the counting. The remaining piece of the puzzle was file i/o, so I looked up python's file libraries and implemented what I believe to be a pretty standard line-by-line parsing, keeping only the first word with the highest repeatIndex() score.

Included in this submission are the two sample lines given in the problem description, plus three of my more interesting tests. In the first, words are split across multiple lines, to test the i/o stability. In the second, a word is included which would win the repeatIndex() count if punctuation marks counted (which they don't). The third test is intentionally left blank, to make sure nothing weird happens if the longest word in the document is the empty word.

I wasn't sure whether to keep track of punctuation marks inside a word when outputting the result. Should "We'll just have to guess" output "we'll" or "well"? I decided to take "Any punctuation marks should be ignored" at face value and just strip them for good, but this could be modified if necessary by keeping track of the original word while feeding the sanitize()'d one into repeatIndex().
